/* generated by Buddy 3.0.0-beta-1 */

(function(root) {
	// Load or return cached version of requested module with id 'path' or 'path/index'
	// @param {String} path
	// @return {Object}
	function require (path) {
		// Convert relative path to absolute for cases where 'require' has not been resolved
		// For example, called from outside of a module
		if (!this.module && path.charAt(0) == '.') {
			path = path.slice((path.indexOf('..') === 0) ? 3 : 2);
		}
		// Find in cache
		var m = require.modules[path] || require.modules[path + '/index'];
		if (!m) {
			// Handle versioned modules when called without version number
			var p, p2, idx;
			for (var p in require.modules) {
				if ((idx = p.indexOf('@')) != -1) {
					p2 = p.slice(0, idx);
					if (path == p2) {
						m = require.modules[p];
						break;
					}
				}
			}
			if (!m) throw "Couldn't find module for: " + path;
		}
		// Instantiate the module if it's export object is not yet defined
		if (!m.exports) {
			// Convert 'lazy' evaluated string to Function
			if ('string' == typeof m) {
				m = require.modules[path] = new Function('module', 'exports', 'require', m);
			}
			m.exports = {};
			m.filename = path;
			m.call(this, m, m.exports, require.relative(path));
		}
		// Return the exports object
		return m.exports;
	}

	// Cache of module objects
	require.modules = {};

	// Resolve 'to' an absolute path
	// @param {String} curr
	// @param {String} path
	// @return {String}
	require.resolve = function(from, to) {
		var fromSegs = from.split('/')
			, seg;

		// Non relative path
		if (to.charAt(0) != '.') return to;

		// Don't strip root paths (handled specially in require())
		if (fromSegs.length > 1) fromSegs.pop();
		to = to.split('/');
		// Use 'from' path segments to resolve relative 'to' path
		for (var i = 0; i < to.length; ++i) {
			seg = to[i];
			if (seg == '..') {
				fromSegs.pop();
			} else if (seg != '.') {
				fromSegs.push(seg);
			}
		}
		return fromSegs.join('/');
	};

	// Partial completion of the module's inner 'require' function
	// @param {String} path
	// @return {Object}
	require.relative = function(path) {
		return function(p) {
			return require(require.resolve(path, p));
		};
	};

	// Register a module with id of 'path' and callback of 'fn'
	// @param {String} path
	// @param {Function} fn [signature should be of type (module, exports, require)]
	require.register = function(path, fn) {
		require.modules[path] = fn;
	};

	// Expose
	root.require = require;
})((typeof window !== 'undefined') ? window : global);
require.register('@yr/number-utils#0.2.2', function(module, exports, require) {
  exports.TWO_PI = (function() {
  	return Math.PI * 2;
  })();
  
  exports.HALF_PI = (function() {
  	return Math.PI * 0.5;
  })();
  
  /**
   * Converts a given value in degrees to radians
   * @param {Number} deg
   * @returns {Number}
   */
  exports.degreesToRadians = function(deg) {
  	return (deg * Math.PI) / 180;
  };
  
  /**
   * Converts a given value in radians to degrees
   * @param {Number} rad
   * @returns {Number}
   */
  exports.radiansToDegrees = function(rad) {
  	return (180 * rad) / Math.PI;
  };
  
  /**
   * Takes a 'value' within a given range and converts it to a number between 0 and 1.
   * @param {Number} value
   * @param {Number} minimum
   * @param {Number} maximum
   * @returns {Number}
   */
  var normalize = exports.normalize = function(value, min, max) {
  	if (min === max) {
  		return 1;
  	} else {
  		return (value - min) / (max - min);
  	}
  };
  
  /**
   * Takes a normalized value and a range and returns the actual value in that range.
   * @param {Number} normValue
   * @param {Number} minimum
   * @param {Number} maximum
   * @returns {Number}
   */
  var interpolate = exports.interpolate = function(normValue, min, max) {
  	return min + (max - min) * normValue;
  };
  
  /**
   * Takes a value in a given range (min1, max1) and finds the corresonding value in the next range (min2, max2).
   * @param {Number} value
   * @param {Number} min1
   * @param {Number} max1
   * @param {Number} min2
   * @param {Number} max2
   * @returns {Number}
   */
  var map = exports.map = function(value, min1, max1, min2, max2) {
  	return interpolate(normalize(value, min1, max1), min2, max2);
  };
  
  /**
   * Takes a value and limits it to fall within a given range.
   * @param {Number} value
   * @param {Number} minimum
   * @param {Number} maximum
   * @returns {Number}
   */
  var limit = exports.limit = function(value, min, max) {
  	return Math.min(Math.max(min, value), max);
  };
  
  /**
   * Generates a random number between a given range.
   * @param {Number} min
   * @param {Number} max
   * @returns {Number}
   */
  var rangedRandom = exports.rangedRandom = function(min, max) {
  	return map(Math.random(), 0, 1, min, max);
  };
  
  /**
   * Rounds a value to the number of specified decimal places
   * @param {Number} value
   * @param {Number} decimalPlaces
   * @returns {Number}
   */
  exports.round = function (value, decimalPlaces) {
  	var parts = value.toString().split('.');
  
  	// Skip if integer
  	if (parts.length == 1) {
  		return value;
  	} else {
  		var pre = parts[0] + parts[1].substr(0, decimalPlaces)
  			, post = parts[1].slice(decimalPlaces)
  			, postRound = Math.round(post/Math.pow(10, (post.length)))
  			, places = Math.pow(10, (decimalPlaces || 0));
  
  		return (parts[1].length <= decimalPlaces) ? value : (+pre + postRound) / places;
  	}
  };
});
require.register('geodist/index.js', function(module, exports, require) {
  var numberUtils = require('@yr/number-utils#0.2.2')
  
  	, RADIUS_UNITS = {
  			'feet': 20908800,
  			'yards': 6969600,
  			'miles': 3960,
  			'mi': 3960,
  			'kilometers': 6371,
  			'km': 6371,
  			'meters': 6371000,
  			'm': 6371000
  		}
  	, DEFAULT_UNIT = 'meters';
  
  module.exports = getDistance;
  
  /**
   * Retrieve geographic distance between 'start' and 'end' lat/lon points
   * Options:
   *  - {Boolean} exact: return floating point value (default false)
   *  - {Boolean} format: return value + unit as string (default false)
   *  - {Number} limit: return boolean value if calculated distance is greater
   *  - {String} unit: return value in specified unit (default meters)
   *
   * @param {Object} start
   * @param {Object) end
   * @param {Object) options
   * @returns {Number}
   */
  function getDistance (start, end, options) {
  	options = options || {};
  
  	var earthRadius = getEarthRadius(options.unit)
  		, latDelta = numberUtils.degreesToRadians(end.lat - start.lat)
  		, latDeltaSin = Math.sin(latDelta * 0.5)
  		, lonDelta = numberUtils.degreesToRadians(end.lon - start.lon)
  		, lonDeltaSin = Math.sin(lonDelta * 0.5)
  		, startLatRad = numberUtils.degreesToRadians(start.lat)
  		, endLatRad = numberUtils.degreesToRadians(end.lat)
  		, a = (latDeltaSin * latDeltaSin) + (lonDeltaSin * lonDeltaSin * Math.cos(startLatRad) * Math.cos(endLatRad))
  		, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
  		, dist = earthRadius * c;
  
  	if (!options.exact) dist = Math.floor(dist);
  	if (options.limit) return (options.limit > dist) ? true : false;
  	if (options.format) dist = '' + dist + ' ' + (options.unit || DEFAULT_UNIT);
  
  	return dist;
  }
  
  /**
   * Retrieve radius of earth in specified 'unit'
   * @param {String} unit
   * @returns {Number}
   */
  function getEarthRadius (unit) {
  	unit = unit || DEFAULT_UNIT;
  	unit = unit.toLowerCase();
  	if (!RADIUS_UNITS[unit]) unit = DEFAULT_UNIT;
  
  	return RADIUS_UNITS[unit];
  }
});
require('geodist/index.js');